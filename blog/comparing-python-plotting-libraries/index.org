#+BEGIN_COMMENT
.. title: Comparing python plotting libraries
.. slug: comparing-python-plotting-libraries
.. date: 2017-12-23 13:33:34 UTC-06:00
.. tags: python,r,learning
.. category: 
.. link: 
.. description: 
.. type: text
#+END_COMMENT


* Introduction

As mentioned in a [[https://jwhendy.github.io/blog/translating-r-to-python/][previous post]], I've been trying to pick up =python=, coming from mostly
using =R= over the past 5-7 years for data analysis, stats, and a lot of plotting. I found
=python='s plotting landscape quite a bit more confusing than I expected, with tons of
options compared to the typical reigning =R= champions: =base=, [[http://lattice.r-forge.r-project.org/][=lattice=]], and [[http://ggplot2.org/][=ggplot2=]]. 

Granted, there are a ton of other R contenders as well, such as [[https://plot.ly/r/][=plotly=]] and [[https://ramnathv.github.io/rCharts/][=rCharts=]],
but the three above are the most common. I stick almost exclusively to =ggplot2=, and
rarely find something I can't do (granted, this is typical science-y stuff, not
infographics or really complicated stuff). To educate myself, I went through and plotted a
pretty standard dataset in various ways to see how one would do it in a bunch of =python=
libraries:

- [[http://ggplot.yhathq.com/][=ggpy=]]
- [[https://matplotlib.org/][=matplotlib=]]
- [[https://seaborn.pydata.org/][=seaborn=]]
- [[https://plot.ly/python/][=plotly=]]
- [[https://plot.ly/ipython-notebooks/cufflinks/][=cufflinks=]]
- [[https://altair-viz.github.io/][=altair=]]
- [[https://bokeh.pydata.org/en/latest/][=bokeh=]]
- [[http://pygal.org/en/stable/][=pygal=]]

* The example

I started /really/ simple. Three types of plots: a simple bar, a dot plot (basically a
bar plot, but makes Tufte proud with a higher data:ink ratio), and a scatter plot colored
by group.

The bar chart in R:

#+begin_src R :session r :results silent :eval no

library(ggplot2)
data(mtcars)

df <- mtcars[1:5, ]
df$car <- rownames(df)

ggplot(df, aes(x = car, y = mpg)) + geom_bar(stat="identity")

#+end_src

A dot plot:

#+begin_src R :session r :results silent :eval no

ggplot(df, aes(x = car, y = mpg)) + geom_point() + expand_limits(y=0)

#+end_src

And lastly, we'll use a bit more data and do a colored scatter plot:

#+begin_src R :session r :results silent :eval no

df <- mtcars[1:10, ]
df$car <- rownames(df)

ggplot(df, aes(x = wt, y = mpg, colour = car)) + geom_point()

#+end_src

Here are our three plots:

#+begin_export html 

<table>
  <td>
    <tr>
      <a href="../../img/r_mtcars_bar.png"><img src="../../img/r_mtcars_bar.png" width="30%" /></a>
    </tr>
  </td>
  <td>
    <tr>
      <a href="../../img/r_mtcars_dot.png"><img src="../../img/r_mtcars_dot.png" width="30%" /></a>
    </tr>
  </td>
  <td>
    <tr>
      <a href="../../img/r_mtcars_scatter_color.png"><img src="../../img/r_mtcars_scatter_color.png" width="30%" /></a>
    </tr>
  </td>
</table>

#+end_export

* ggpy

Porting =ggplot2= to =python= is an /amazing/ concept. The whole idea behind the grammar
of graphics is how little the code needs to change for different visualizations. We're
only changing some mappings (some aspect of the data leads to some aesthetic) and the
geometry being used.

The above is /almost/ identical using the port for the bar chart. I dislike that the
aesthetic keyword is =weight= and not simply =y=. This [[https://github.com/yhat/ggpy/issues/373][surprised someone else]], too. It
also causes there to be no y-axis label by default; I had to manually add it in.

I also don't love how =ggpy= handles limits. Note the dot plot from =ggplot2= and the
nice little padding above the highest dot. In =ggpy=, this didn't seem to work well out of
the box. I could fix it with =scale_y_continuous=, but why should I have to? This also
makes for requiring what I consider hokey, like:

#+begin_example
... + scale_y_continuous(limits=(0, max(df['mpg'])*1.1))
#+end_example

I /could/ do that, but again, it's extra effort. In my own workflow, I find I'm often
visualizing some variables pretty similarly. I'll copy and paste code blocks and switch
out variable names. This is one more thing to need to remember, and perhaps the 1.1
multiplier wouldn't work so well if the data range was different by an order or two of
magnitude. Smart ranges should "just work" in my opinion.

Another complaint has to do with saving out the files. I'm not showing it below, but these
were each generated with:

#+begin_example
p = ggplot(...)
p.save('filename.png', width=w, height=h, dpi=300)
#+end_example

For the bar and dot, things were fine using ~width=9, height=6~ (inches), but using this
for the scatter seemed not to incorporate the legend in the width. Using the same size, I
got this:

#+attr_html: :width 600px
[[../../img/ggpy_mtcars_scatter_color_crunch.png]]

To get the legend to fit, I had to bump the size, but that makes the text labels much
smaller with respect to the plot. In =ggplot=, I could fix this with some =theme()= options; I didn't get far
enough to hunt the equivalent in =ggpy=.

#+begin_example 
from ggplot import *

ggplot(df, aes(x='car', weight='mpg')) + geom_bar(stat='identity') + scale_y_continuous('mpg')
#+end_example

For the dot plot, note the switch back to ~y=~:

#+begin_example 
ggplot(df, aes(x='car', y='mpg')) + geom_point() + ylim(low=0)
#+end_example

And the scatter plot:

#+begin_example  
ggplot(df, aes(x='wt', y='mpg', color='car')) + geom_point()
#+end_example

Here's what we get!

#+begin_export html
<table>
  <td>
    <tr>
      <a href="../../img/ggpy_mtcars_bar.png"><img src="../../img/ggpy_mtcars_bar.png" width="30%" /></a>
    </tr>
  </td>
  <td>
    <tr>
      <a href="../../img/ggpy_mtcars_dot.png"><img src="../../img/ggpy_mtcars_dot.png" width="30%" /></a>
    </tr>
  </td>
  <td>
    <tr>
      <a href="../../img/ggpy_mtcars_scatter_color.png"><img src="../../img/ggpy_mtcars_scatter_color.png" width="30%" /></a>
    </tr>
  </td>
</table>
#+end_export


* matplotlib

From my reading, this looks like the loved and hated "bread and butter" of =python=
plotting. I think the biggest complaint I've seen is the verbosity. I didn't experience
much of this, likely due to how simple these examples are.

I ran into the same quirk as with =ggpy= with respect to expanding the dot plot y-axis
limits. I could pass =ylim(0)= to get zero included, but it would cut off the top dot. I
had to do the hokey scaling bit again.

Lastly, the process of getting colors by groups was not awesome. I found I could sort of
[[https://stackoverflow.com/questions/26139423/plot-different-color-for-different-categorical-levels-using-matplotlib][manually map]] each group to a color or do it the canonical way and [[https://stackoverflow.com/questions/43967663/scatter-plot-with-legend-colored-by-group-without-multiple-calls-to-plt-scatter][loop through]] the data,
adding a layer of dots for each group. That also required some fiddling with the [[https://matplotlib.org/users/legend_guide.html#legend-location][legend location]].

The bar plot:

#+begin_src python 
import matplotlib.pyplot as plt

plt.figure(figsize=(9, 6))
plt.bar(df['car'], df['mpg'])
plt.show()
#+end_src

Dot plot:

#+begin_src python 
plt.figure(figsize=(9, 6))
plt.scatter(df['car'], df['mpg'])
plt.ylim(0, max(df['mpg'])*1.1)
plt.show()
#+end_src

For the colored scatter plot, which I had a [[https://stackoverflow.com/questions/47956746/saving-matplotlib-subplot-axes-as-png-file][helluva time]] getting to save as a file. I
originally had to just screenshot the plot from =jupyter lab=, but ended up getting the
answer, which was that my =plt.figure()= (now commented) goofs with the =plt.subplots()=
command.

#+begin_src python 
fig, ax = plt.subplots()
# plt.figure(figsize=(12, 9))
for ind in df.index:
    ax.scatter(df.loc[ind, 'wt'], df.loc[ind, 'mpg'], label=ind)
ax.legend(bbox_to_anchor=(1.05, 1), loc=2)
plt.show()
#+end_src

#+begin_export html 
<table>
  <td>
    <tr>
      <a href="../../img/mat_mtcars_bar.png"><img src="../../img/mat_mtcars_bar.png" width="30%" /></a>
    </tr>
  </td>
  <td>
    <tr>
      <a href="../../img/mat_mtcars_dot.png"><img src="../../img/mat_mtcars_dot.png" width="30%" /></a>
    </tr>
  </td>
  <td>
    <tr>
      <a href="../../img/mat_mtcars_scatter_color.png"><img src="../../img/mat_mtcars_scatter_color.png" width="30%" /></a>
    </tr>
  </td>
</table>

#+end_export

* seaborn

Seaborn was pretty straightforward. Not much else to say!


#+begin_src python :eval no 
import seaborn as sns

plt.figure(figsize=(9, 6))
sns.barplot(x='car', y='mpg', data=df)
plt.show()
#+end_src

#+begin_src python :eval no
plt.figure(figsize=(9, 6))
sns.stripplot(x='car', y='mpg', data=df)
plt.ylim(0)
plt.show()
#+end_src

#+begin_src python :eval no 
sns.lmplot(x='wt', y='mpg', hue='car',
           data=df, fit_reg=False)
plt.show()
#+end_src

#+begin_export html 
<table>
  <td>
    <tr>
      <a href="../../img/sea_mtcars_bar.png"><img src="../../img/sea_mtcars_bar.png" width="30%" /></a>
    </tr>
  </td>
  <td>
    <tr>
      <a href="../../img/sea_mtcars_dot.png"><img src="../../img/sea_mtcars_dot.png" width="30%" /></a>
    </tr>
  </td>
  <td>
    <tr>
      <a href="../../img/sea_mtcars_scatter_color.png"><img src="../../img/sea_mtcars_scatter_color.png" width="30%" /></a>
    </tr>
  </td>
</table>
#+end_export

* plotly

For these plots, I left in the =jupyter lab= commands for plotting. To save them out, I
clicked the camera icon in the =plotly= embedded plot. Surprisingly, you can [[https://community.plot.ly/t/use-plotly-offline-to-save-chart-as-image-file/408/28][find evidence]]
that people want to save directly, and [[https://stackoverflow.com/questions/40243446/how-to-save-plotly-offline-graph-in-format-png][the solution]] is not awesome:

#+begin_example 
plotly.offline.plot(trace, image='png', image_filename='filename')
#+end_example

For me, this opens a new tab and automatically saves the file. It saves it in
=~/Downloads=, not my current directory, though.

The bar plot was pretty straightforward:

#+begin_src python :eval no 

import plotly
import plotly.graph_objs as go

plotly.offline.init_notebook_mode()

trace = [go.Bar(x = df['car'],
                y = df['mpg'])]
plotly.offline.iplot(trace)

#+end_src

Same for the dot plot, though note we have to fiddle with the =layout= object to expand
our y-axis limits.

#+begin_src python :eval no 

data = [go.Scatter(x = df['car'],
                    y = df['mpg'],
                    mode='markers')]
layout = go.Layout(yaxis={'range': [0, max(df['mpg'])*1.1]})
fig = go.Figure(data=data, layout=layout)

plotly.offline.iplot(fig)

#+end_src

The colored scatter plot were where things really broke down for me. I admit that I really
/want/ to love =python= and have heard it touted as one of the top data science/analysis
languages. Waaayyy back, I took quite a bit of time to research programmatic ways to do
analysis, stats, and plotting. I was really just trying to find some alternative to my
company's typical option of Minitab for this type of work. I wanted it to work from linux,
and ideally be compatible with my beloved [[http://orgmode.org/][=orgmode=]]. Typical contenders included =R=,
=python=, and =octave=. For better or worse, I went with =R= and sort of didn't look
back.

Now, I'm coming into =python= for some other work projects and am honestly sort of feeling
spoiled coming from =R=. It's so concise and, well, easy! It had some odd syntax for sure,
but it just feels so easy to accomplish what I want.

So, all of this is to say that I was a bit blown away going to find out how to color by
group in one of the fancy new plotting libraries (which includes paid options!) and
finding things like:

Plotly's [[https://plot.ly/python/line-and-scatter/#scatter-with-a-color-dimension][example]] of "scatter with a color dimension", which is also the [[https://www.google.com/search?q=color+by+group+plotly+python][top google hit]] for
"color by group plotly python."

#+begin_src python

trace1 = [go.Scatter(
    y = np.random.randn(500),
    mode='markers',
    marker=dict(
        size='16',
        color = np.random.randn(500), #set color equal to a variable
        colorscale='Viridis',
        showscale=True
    )
)]

#+end_src

That's it. The key line in there is ~color=np.random()~, which only addresses a continuous color
scale. Thinking looking for [[https://plot.ly/python/colorscales/][color scale]] information would be helpful also wasn't. It just
shows a bunch of ways to put up continuous colors scales, not discrete for groups.

A little further up, we have this kludge:

#+begin_src python 
c = ['hsl('+str(h)+',50%'+',50%)' for h in np.linspace(0, 360, N)]

for i in range(int(N)):
    ...
    trace0= go.Scatter(
    ...
        marker= dict(
	    ...
            color= c[i]
        ), name= y[i],
    l.append(trace0);
#+end_src

[[https://plot.ly/python/group-by/][Elsewhere]], =plotly= suggests this, which seems silly in and of itself, but especially for a large set:

#+begin_src python 

transforms = [dict(
    type = 'groupby',
    groups = subject,
    styles = [
        dict(target = 'Moe', value = dict(marker = dict(color = 'blue'))),
        dict(target = 'Larry', value = dict(marker = dict(color = 'red'))),
        dict(target = 'Curly', value = dict(marker = dict(color = 'black')))
    ]
  )]

#+end_src

The [[https://stackoverflow.com/questions/43596354/plotly-change-color-by-group][highest search result]] from SO just says to use another library (=colorlover=)!

When I see things like this, my first reaction is honestly that it must not be true;
there's /no way/ I'm reading the documentation right. This is after spending a long time 
with =ggplot2=, however, where the key point is that visualization is simply about mapping
aesthetics to aspects of the data.

The above seems to make me a slave to the data... it already constains distinctions
(unique values); why do I need to tell my plotting library how to map these to colors?
This strikes me as having to create a =dict()= mapping x and y numeric values to their
eventual locations in pixels.

Sort of by accident I stumbled on [[https://plot.ly/python/line-and-scatter/][this doc page]] that didn't appear to be trying to tell me
anything about groups, but inadvertently made it evident a separate list of =go.Scatter=
objects would get me discrete colors for free. So I ended up with this:

#+begin_src python

data = [go.Scatter(x=[df['wt'][i]],
                   y=[df['mpg'][i]],
                   mode='markers',
                   name=df['car'][i],
                   text=df['car'][i]) for i in range(len(df))]

plotly.offline.iplot(data)

#+end_src

To be fair, I like plotly. I like the hover text, especially for larger datasets where
colors actually aren't the best way to tell them apart. Even with these 10 cars, the
colors are hard to distinguish. The ability to put in ~text=foo~ is super handy. Our finished result:

#+begin_export html 
<table>
  <td>
    <tr>
      <a href="../../img/plotly_mtcars_bar.png"><img src="../../img/plotly_mtcars_bar.png" width="30%" /></a>
    </tr>
  </td>
  <td>
    <tr>
      <a href="../../img/plotly_mtcars_dot.png"><img src="../../img/plotly_mtcars_dot.png" width="30%" /></a>
    </tr>
  </td>
  <td>
    <tr>
      <a href="../../img/plotly_mtcars_scatter_color.png"><img src="../../img/plotly_mtcars_scatter_color.png" width="30%" /></a>
    </tr>
  </td>
</table>
#+end_export


* cufflinks

I don't have much to say here; it's supposed to be a way to sort of layer =plotly= right
onto =pd.DataFrame= objects. That makes it really succinct, but I also find the
documentation lacking.

#+begin_src python 
import cufflinks as cf

df.iplot(kind='bar', x='car', y='mpg')
#+end_src

This /does/ show how nice the grammar of graphics is. Other than needing to specify that
we want =markers=, we're literally just changing the =kind= of plot with the mappings
staying the same. It's just a different way to draw the same thing.

#+begin_src python 
df.iplot(kind='scatter', x='car', y='mpg', mode='markers')
#+end_src

The grouped colors fell apart a bit for me again, perhaps because at the end of the day
=cufflinks= is just =plotly=. I found [[https://github.com/santosjorge/cufflinks/blob/master/Cufflinks%20Tutorial%20-%20Colors.ipynb][this promising]] walkthrough, but one of the
colorscale generation examples failed me. In the
[[https://plot.ly/ipython-notebooks/cufflinks/#scatter-plot][cufflinks docs]] themselves, they basically say this isn't possible and just fallback to
=plotly= syntax:

#+begin_quote
Plotting multiple column scatter plots isn't as easy with cufflinks. Here is an example
with Plotly's native syntax
#+end_quote

So, I'll pass since I did this with =plotly= above already...

#+begin_export html 
<table>
  <td>
    <tr>
      <a href="../../img/cf_mtcars_bar.png"><img src="../../img/cf_mtcars_bar.png" width="30%" /></a>
    </tr>
  </td>
  <td>
    <tr>
      <a href="../../img/cf_mtcars_dot.png"><img src="../../img/cf_mtcars_dot.png" width="30%" /></a>
    </tr>
  </td>
  <td>
    <tr>
      <a href="../../img/plotly_mtcars_scatter_color.png"><img src="../../img/plotly_mtcars_scatter_color.png" width="30%" /></a>
    </tr>
  </td>
</table>
#+end_export


* altair

I learned about =altair= from one of the inspirations between this exercise, which was a
[[https://www.youtube.com/watch?v=FytuB8nFHPQ][talk from Jake VanderPlas]] on the =python= visualization landscape. It was a great overview
of a bunch of what's out there, and it's even more impressive that he traced their sort of
"lineage" and how they relate to one another.

I quite enjoy =altair=; I feel like it does the grammar of graphics nicely, and it's not
too cumbersome. One downside is that I couldn't get the chart size to play along, but it
apparently works for other types, maybe just [[https://github.com/altair-viz/altair/issues/173#issuecomment-353702876][not bars]]?

#+begin_src python 
import altair as alt
alt.enable_mime_rendering()

alt.Chart(df).mark_bar().encode(x='car', y='mpg')
#+end_src


#+begin_src python 
alt.Chart(df).mark_point().encode(x='car', y='mpg')
#+end_src

Awesomely, the mapping was perfectly beautiful for adding color and I guessed, not even
looking at the syntax!

#+begin_src python 
alt.Chart(df).mark_point().encode(x='wt', y='mpg', color='car')
#+end_src

#+begin_export html 
<table>
  <td>
    <tr>
      <a href="../../img/alt_mtcars_bar.png"><img src="../../img/cf_mtcars_bar.png" width="30%" /></a>
    </tr>
  </td>
  <td>
    <tr>
      <a href="../../img/alt_mtcars_dot.png"><img src="../../img/cf_mtcars_dot.png" width="30%" /></a>
    </tr>
  </td>
  <td>
    <tr>
      <a href="../../img/alt_mtcars_scatter_color.png"><img src="../../img/alt_mtcars_scatter_color.png" width="30%" /></a>
    </tr>
  </td>
</table>
#+end_export
